### Установка на Windows
Для ПК без доступа в интернет запустить bat-файл: **install_packages_from_folder.bat**
В результате устанавливаются необходимые пакеты, которые заранее скачаны и располагаются в папке Requiremets
Если на ПК имеется доступ в интерент и к репозиторию PyPi.org, можно установить текущие версии, запустив bat-файл: **install_packages_from_internet.bat**

### Запуск приложения
Запуск можно производить bat-файлом: **pypunto.bat**
Контроля повторного запуска пока нет, поэтому при многократном запуске приложения оно не будет корректно работать. Рекомендую поместить **pypunto.bat** в автозагрузку и вручную не запускать.

### PyPunto на страже безопасного удобства…
Большинство крупных компаний серьезно относится к безопасности и утечкам данных, которые могут возникнуть в том числе по вине программного обеспечения, обладающего функциями записи нажатий клавиш на клавиатуре. В этой статье я хочу рассказать на примере своего опыта, как можно сохранить удобство и при этом не проиграть в безопасности данных, если ранее Вы пользовались одной-двумя функциями Punto Switcher – заменой последнего слова или выделенного фрагмента.

В качестве языка программирования я выбрал Python.

Меня сразу заинтересовала возможность найти какой-то аналог, который хоть как-то облегчит нашу жизнь. Порывшись по интернету, я нашел пару статей, в которых авторы решали аналогичную задачу – один в силу своих специфических требований, другой – из-за недоверия к чужой программе, которая считывает все, что набирается на клавиатуре.

В этом плане скрипты Python, благодаря открытости кода, имеют преимущество перед закрытыми аналогами. 
Ознакомившись с существующими скриптами, при попытке воспользоваться ими, я наткнулся на некоторые препятствия. Да и скрипты не отвечали тем желаниям, которые у меня были. Например, при запуске такой скрипт «висел» как консольное окно и, при случайном его закрытии переставал работать. 
В итоге, я написал свой «Punto Switcher» на Python’е (и назвал его PyPunto), чем и хочу поделиться с вами. 

Итак, разобравшись с прокси и установкой дополнительных пакетов python, я решил сделать все красиво – чтобы была иконка в системном трее, менюшка для выхода, и чтобы консольное окно не мозолило глаза. 
Первым делом сделал скрипт с расширением “pyw” – такие скрипты запускаются по умолчанию в оконном режиме.
Потом, для создания иконки в системном трее, я отыскал пример использования пакета wxPython. 
https://pypi.org/project/wxPython/
```
pip install wxPython
```

Всего для реализации было использовано четыре сторонних модуля, плюс зависимости (но их там минимум):
```python
import time
import py_win_keyboard_layout
import pyperclip
import wx
import wx.adv
from pynput import keyboard
from pynput.keyboard import Controller, Key, KeyCode
```

«time» – стандартный; использован для создания пауз между командами.

За переключение раскладки клавиатуры отвечает «py_win_keyboard_layout»;
https://pypi.org/project/py_win_keyboard_layout/
```
pip install py_win_keyboard_layout
```

«pyperclip» – для работы с буфером обмена
https://pypi.org/project/pyperclip/
```
pip install pyperclip
```

«pynput» – для работы с клавиатурой (модуль также позволяет работать и с мышкой)
https://pypi.org/project/pynput/
```
pip install pynput
```

При написании программы и тестировании я перепробовал несколько библиотек для работы с клавиатурой. У каждой были какие-то критичные недостатки. Даже у “pynput”, на которой я остановился, оказался неприятный момент с глобальными сочетаниями – если задать комбинации shift+scroll_lock и просто scroll_lock, то при нажатии комбинации будет срабатывать событие на простой scroll_lock. Но за счет возможности просто получать все нажатия клавиш, удалось нормально использовать эту библиотеку. В плюс к этому, pynput не перестает работать после блокировки ПК, в отличие от “global-hotkeys”.
В плане примера мне очень помогла статья:
https://nitratine.net/blog/post/how-to-make-hotkeys-in-python/
Пример из статьи, как мне кажется, тоже не очень правильный, но я взял его за основу и сделал чуть-чуть по-другому. Отладка на практике показывает, что мой вариант работает более стабильно.

Механизм «перевода» сделан в некотором роде в виде эмуляции действий пользователя. При нажатии заданной комбинации клавиш, программа выделяет слово или строчку эмулируя нажатие клавиш “End”, “Shift+Home” и т.п., потом производит копирование в буфер обмена комбинацией “Ctrl+C”, текст из буфера обмена «переводится» и отправляется обратно, вместо выделенного, с помощью эмуляции нажатий “Ctrl+V”. Такие комбинации работают во всех текстовых редакторах, с которыми я и моя команда сталкиваемся ежедневно. Даже если встретится какой-то особенный случай, можно просто создать еще один метод и в нем использовать другие сочетания. Есть у такого способа и недостаток. В одном из редакторов – Visual Studio Code – если ничего не выделять и нажать на Ctrl+C, то копируется вся строка. При этом скрипт PyPunto думает, что есть выделение и просто вставляет перевод в конец строки. Как обойти такое поведение простым способом, я не придумал, поэтому именно в этом редакторе приходится самому выделять исправляемую строчку.

На данный момент реализованы 4 варианта переключения:
1.	Ctrl_L+Alt_L+PgUp - Приведение текста к верхнему регистру
2.	Ctrl_L+Alt_L+PgDn - Приведение текста к нижнему регистру
3.	Ctrl_L+Alt_L+Insert – Переворачивание регистра
4.	Scroll_Lock – замена выделенного фрагмента или всей строки, если ничего не выделено.

Алгоритм перевода сделан наипростейшим способом: два набора символов русской и английской раскладок. Переводимый текст может быть целой строкой с чередованием языков и символов. 

Поскольку некоторые символы встречаются на обеих раскладках, алгоритм сделал так, что в процессе перевода запоминаем, в какой раскладке был последний переведенный символ и если на пути попадается спорный (который присутствует в обеих раскладках), то используем язык, который был в предыдущем не спорном символе. 

Словари не используются и лингвистический анализ не производится. После «перевода» последнего выделенного символа, производится переключение раскладки клавиатуры на английский язык, если последний символ был перекодирован в английский, или на русский, если последний символ был перекодирован в русский.

Сам код PyPunto довольно простой, так что думаю, что даже такой новичок в Python как я разберется, но я дополнительно еще прокомментировал в коде некоторые не очевидные моменты. 

Код был протестирован на Windows 10, но исходя из того, что все использованные библиотеки платформенно-независимые, то теоретически он должен работать и на других системах с возможными ограничениями по использованию некоторых клавиш.
